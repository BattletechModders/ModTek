using System;
using System.Collections.Generic;
using BattleTech;
using BattleTech.Data;
using Harmony;
using UnityEngine;

namespace ModTek.Features.LoadingCurtainEx
{
    internal class DataManagerLoadingCurtain
    {
        private static LoadStats LastStats = new();
        // returns true if new stats, false if nothing changed and then returns old stats
        internal static bool GetDataManagerStats(out LoadStats stats)
        {
            var dataManager = UnityGameInstance.BattleTechGame.DataManager;
            var activeLoadBatches = Traverse
                .Create(dataManager)
                .Field("activeLoadBatches")
                .GetValue<List<LoadRequest>>();

            if (activeLoadBatches == null || activeLoadBatches.Count == 0)
            {
                stats = null;
                return false;
            }

            stats = new LoadStats(activeLoadBatches);

            if (!stats.HasStats())
            {
                return false;
            }

            if (stats.Equals(LastStats))
            {
                stats = LastStats;
                if (!stats.dumped && Time.realtimeSinceStartup - stats.time > ModTek.Config.DataManagerEverSpinnyDetectionTimespan)
                {
                    stats.dumped = true;
                    DumpLoadRequests.DumpProcessing(stats, activeLoadBatches);
                }
                return false;
            }

            LastStats = stats;
            return true;
        }

        private class LoadRequestTraverse
        {
            internal readonly LoadRequest instance;
            private readonly Traverse traverse;

            internal LoadRequestTraverse(LoadRequest instance)
            {
                this.instance = instance;
                traverse = Traverse.Create(instance);
            }

            internal int GetActiveRequestCount() => traverse.Method("GetActiveRequestCount").GetValue<int>();
            internal int GetPendingRequestCount() => traverse.Method("GetPendingRequestCount").GetValue<int>();
            internal int GetCompletedRequestCount() => traverse.Method("GetCompletedRequestCount").GetValue<int>();
        }

        internal class LoadStats: IEquatable<LoadStats>
        {
            internal readonly int batches;
            internal readonly int active;
            internal readonly int pending;
            internal readonly int completed;
            internal readonly int failed;
            internal readonly float time = Time.realtimeSinceStartup;
            internal bool dumped;

            internal LoadStats()
            {
            }

            internal LoadStats(List<LoadRequest> loadRequests)
            {
                foreach (var load in loadRequests)
                {
                    var lrt = new LoadRequestTraverse(load);
                    batches++;
                    active += lrt.GetActiveRequestCount();
                    pending += lrt.GetPendingRequestCount();
                    completed += lrt.GetCompletedRequestCount();
                    failed += lrt.instance.FailedRequests.Count;
                }
            }

            internal bool HasStats()
            {
                return active > 0 || pending > 0 || completed > 0 || failed > 0;
            }

            public override string ToString()
            {
                return $"batches={batches} active={active} pending={pending} completed={completed} failed={failed}";
            }

            internal string GetStatsTextForCurtain()
            {
                var text = $"Batches: {batches}";
                text += $"\nPending: {pending}";
                text += $"\nProcessing: {active}";
                text += $"\nCompleted: {completed}";
                if (failed > 0)
                {
                    text += $"\nFailed: {failed}";
                }
                if (dumped)
                {
                    text += $"\nEverspinny detected, dumped processing to log.";
                }
                return text;
            }

            // below methods generated by Rider
            public bool Equals(LoadStats other)
            {
                if (ReferenceEquals(null, other))
                {
                    return false;
                }

                if (ReferenceEquals(this, other))
                {
                    return true;
                }

                return active == other.active && pending == other.pending && completed == other.completed && failed == other.failed;
            }

            public override bool Equals(object obj)
            {
                if (ReferenceEquals(null, obj))
                {
                    return false;
                }

                if (ReferenceEquals(this, obj))
                {
                    return true;
                }

                if (obj.GetType() != this.GetType())
                {
                    return false;
                }

                return Equals((LoadStats)obj);
            }

            public override int GetHashCode()
            {
                unchecked
                {
                    var hashCode = active;
                    hashCode = (hashCode * 397) ^ pending;
                    hashCode = (hashCode * 397) ^ completed;
                    hashCode = (hashCode * 397) ^ failed;
                    return hashCode;
                }
            }
        }
    }
}
